# Chapter 17 优于'select'的'epoll'



##  17.1基于select的I/O多路复用技术性能相对劣势的原因



- <font sie =4>**内核中实现 select是用轮询方法，即每次检测都会遍历所有`FD_SET`中的句柄**</font>

 高并发的核心解决方案是1个线程处理所有连接的“等待消息准备好”，这一点上epoll和select是无争议的。但select预估错误了一件事，当数十万并发连接存在时，可能每一毫秒只有数百个活跃的连接，同时其余数十万连接在这一毫秒是非活跃的。select的使用方法是这样的：
$$
   返回的活跃连接 ==select（全部待监控的连接）。

$$
   什么时候会调用select方法呢？在你认为需要找出有报文到达的活跃连接时，就应该调用。所以，调用select在高并发时是会被频繁调用的。这样，这个频繁调用的方法就很有必要看看它是否有效率，因为，它的轻微效率损失都会被“频繁”二字所放大。它有效率损失吗？显而易见，<font color =blue>全部待监控连接是数以十万计的，返回的只是数百个活跃连接，这本身就是无效率的表现。</font>被放大后就会发现，处理并发上万个连接时，select就完全力不从心了。



- <font sie =4>**每次调用select前都需要向该函数传递监视对象的信息**</font>

在第十二章代码的循环体内部都会执行如下代码:

```c
int res ; 
temp = reads ;//每次轮询之前都需要进行拷贝,传递监视对象的信息
timeout.tv_sec =5;
timeout.tv_usec = 0;

res = select(1 , &temp , NULL , NULL , &timeout)
```

<font color =red>**每次调用select函数都需要向操作系统传递监视对象的信息**</font>,然而相较于`select`,    `epoll`只需要向操作系统传递一次见识对象, 监视范围或者内容发生变化时只通知发生变化的事项





附:(各I/O复用模型性能基准图)

![](./../phtoto/epoll1.jpg)